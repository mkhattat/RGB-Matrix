 \begin{DoxyAuthor}{Author}
Mostafa Khattat (\href{mailto:mostafa@khattat.nl}{\tt mostafa@khattat.\+nl}) 
\end{DoxyAuthor}
\begin{DoxyVersion}{Version}
1.\+0 (last modified 2016-\/06-\/20) 
\end{DoxyVersion}
\begin{DoxyCopyright}{Copyright}
boost license (some files public domain)
\end{DoxyCopyright}
Smart Matrix is a library to control 64x32 led pannels. A dot-\/matrix display is a display device used to display information, photos or short video clip animations. The display consists of a dot matrix of R\+GB lights arranged in a rectangular configuration such that by switching on or off selected lights, text or graphics can be displayed. Smart Matrix is a library to control such matrix. The library is written in c++ Object Oriented. The main class, \hyperlink{matrix_8hpp}{matrix.\+hpp}, is used to declare and initialize the led matrix and also there are other classes to help you control the led matrix. Here you will find a quick start guide with some example to show you how the library works.

{\bfseries Wiring\+:} 

This section describes default wiring and pins numbers. The R\+GB panels are normally designed for chaining (linking end-\/to-\/end into larger displays)…the output of one panel connects to the input of the next, down the line. Flip the matrix over so you’re looking at the back, holding it with the two sockets situated at the left and right edges. One of them is I\+N\+P\+UT. That\textquotesingle{}s the socket we are intersting.  You need to wire you gpio pins as bellow\+: 

\hypertarget{index_multi_row}{}
\tabulinesep=1mm
\begin{longtabu} spread 0pt [c]{*2{|X[-1]}|}
\caption{Wiring Table}\label{index_multi_row}\\
\hline
\rowcolor{\tableheadbgcolor}{\bf Pin Names }&{\bf Arduino Digital Pin Names }\\\cline{1-2}
\endfirsthead
\hline
\endfoot
\hline
\rowcolor{\tableheadbgcolor}{\bf Pin Names }&{\bf Arduino Digital Pin Names }\\\cline{1-2}
\endhead
R1&digital pin 35 \\\cline{1-2}
B1&digital pin 33 \\\cline{1-2}
R2&digital pin 38 \\\cline{1-2}
B2&digital pin 36 \\\cline{1-2}
R1&digital pin 35 \\\cline{1-2}
A&digital pin 25 \\\cline{1-2}
C&digital pin 27 \\\cline{1-2}
C\+LK&digital pin 39 \\\cline{1-2}
OE&digital pin 42 \\\cline{1-2}
G1&digital pin 34 \\\cline{1-2}
G2&digital pin 37 \\\cline{1-2}
B&digital pin 26 \\\cline{1-2}
D&digital pin 28 \\\cline{1-2}
\end{longtabu}


{\bfseries Matrix\+:} 

To start using the led pannel you have to initialize it. You can do it in two ways\+:
\begin{DoxyItemize}
\item You can use the default wiring (Highly recommended)
\item You can use your own wiring and pinnen (Not recommended! because of performance issues)
\end{DoxyItemize}

Here is such an example of using matrix library with default wiring\+: 
\begin{DoxyCode}
\textcolor{preprocessor}{#include "\hyperlink{matrix_8hpp}{matrix.hpp}"}

\hyperlink{classmatrix}{matrix} led(64, 32, \textcolor{keyword}{true});
led.start();
\end{DoxyCode}


But as already said you can use your own wiring setup. In that case you have to pass the pin number of every wire to the constructor\+: 
\begin{DoxyCode}
\textcolor{preprocessor}{#include "\hyperlink{matrix_8hpp}{matrix.hpp}"}

    \hyperlink{classmatrix}{matrix} led(64, 32, \textcolor{keyword}{true}, target::pins::d43, target::pins::d42, target::pins::d39,
            target::pins::d25, target::pins::d26, target::pins::d27, target::pins::d28,
            target::pins::d33, target::pins::d34, target::pins::d35, target::pins::d36,
            target::pins::d37, target::pins::d38);
    led.start();
\end{DoxyCode}
 The problem with above code is that you can not get the maximum performance out of you microcontroller and thus you will notice flickers and lag in animation. It\textquotesingle{}s recommended to use de default wiring. To setup your led matrix with default wiring use the documentation above. for more information about both constructor refer to \hyperlink{matrix_8hpp}{matrix.\+hpp} class.

In both cases (default wiring or custom wiring) of above examples 64 is the width of led matrix and 32 is the height. Library supports a double buffering. To enable it you should pass true as 3e arrgument. The hardware of led matrix can display only two rows at once. In order to light all pixels we have to turn on and off every row quickly so that in our eyes it seems that the alle pixels are on. To that the library uses a timer interrupt functionality of Arduino Due. led.\+start() enables auto update, so you don\textquotesingle{}t have to worry about turning on or off panel rows.

{\bfseries  Note\+: } The library uses timer interrupt 1 channel 1 to update the led pannel. So if you plan to use timer interrupts in your program you should not use this interrupt channel.

If you enable double buffering, drawing any pixel will occur in the back buffer. The result is not visible until you swap the buffers\+: 
\begin{DoxyCode}
led.drawPixel(0,0, 0xFFFFFF);
led.swap\_buffer(\textcolor{keyword}{false});
\end{DoxyCode}
 In the above example we light up the pixel (0,0) and specify it\textquotesingle{}s color as \char`\"{}\+White\char`\"{}. Colors can be in (hexa)decimal values between 0 and 2$^\wedge$24-\/1 or seprate R\+GB colors\+: 
\begin{DoxyCode}
led.drawPixel(0,0, 255, 255, 255);
\end{DoxyCode}
 Because we already enabled double buffering we have to swap buffers to turn on pixel (0,0). This function requires an bool argument. If you need to copy the values of the updated buffer into the new back buffer you need to pass true to the copy varianle. But if you only need to swap the front buffer with the back buffer and you don\textquotesingle{}t care about the old buffer (maybe because you clear the screen afterwards) the pass false to the copy variable. To avoid \char`\"{}tearing\char`\"{} swapping of buffers takes place at the end of a complete screen refresh cycle.

{\bfseries Note\+: } This function doesn\textquotesingle{}t have any effect if you didn\textquotesingle{}t enable the double buffer in the constructor.

In order to fill the screen with a specific color you can use fillscreen function. 
\begin{DoxyCode}
led.fillScreen(0x87ADFF);
\end{DoxyCode}
 Here you can also use R\+GB colors\+: 
\begin{DoxyCode}
led.fillScreen(135, 173, 255);
\end{DoxyCode}
 There is also a clear function to clear the screen\+: 
\begin{DoxyCode}
led.clear();
\end{DoxyCode}


{\bfseries  Show Images\+: }

With your led pannel you can also show pictures. The max size of pictures should be at the max size of pannel. So if you have a 64 width x 32 height pannel, the size of you pictures should be maximum 64x32. The library does not scale the images for you. The library uses a special raw format for the photos. There is a python command line script helps you convert your images at any format to the required raw format. This python script is readbmp.\+py. In order to use this script you need to install pillow library. 
\begin{DoxyCode}
1 python -m pip install Pillow
\end{DoxyCode}
 The readbmp script needs two arguments, path to the photo and the name of the new raw file\+: 
\begin{DoxyCode}
1 python readbmp.py photo.jpg myphoto
\end{DoxyCode}
 The result is a .h file you can include in your projects and use it to show the photo on the screen\+: 
\begin{DoxyCode}
\textcolor{preprocessor}{#include "myphoto.h"}

\hyperlink{class_image}{Image} im(led, myphoto, \hyperlink{classvector}{vector}(35,0));
im.draw();
led.swap\_buffer(\textcolor{keyword}{false});
\end{DoxyCode}
 in the above example \hyperlink{classvector}{vector(35,0)} is the location of the library. in this library you should pass location and size of something as a \hyperlink{classvector}{vector(x,y)}. See also \hyperlink{vector_8hpp}{vector.\+hpp}

{\bfseries  Show Animated Images\+: }

Not only Images can be shown but Animated Images can also be shown on the led matrix. To use this feature you have to convert a gif animation file to a raw animated image. To do this you can use a python script make\+\_\+animation.\+py. This script depends on a pillow library\+: 
\begin{DoxyCode}
1 /// python -m pip install Pillow
\end{DoxyCode}
 The make\+\_\+animation.\+py script needs two arguments, path to the gif file and the name of the new raw animated file\+: 
\begin{DoxyCode}
1 python make\_animation.py animation.gif myanimation
\end{DoxyCode}
 The result is a .h file you can include in your projects and use it to show the animated image on the screen\+: 
\begin{DoxyCode}
\textcolor{preprocessor}{#include "myanimation.h"}

\hyperlink{class_animated_image}{AnimatedImage} aIm(led, animation, \hyperlink{classvector}{vector}(15, 0));
aIm.draw();
\end{DoxyCode}
 The above code prints animation at location (15, 0). De default is one time from start to end with a update interval 10 milliseconds between each frame. In order to change de update interval and loop option you can declare the function as\+: 
\begin{DoxyCode}
aIm.draw(5, \textcolor{keyword}{true});
\end{DoxyCode}
 The above code prints animation with 5 milliseconds update interval between each frame and loop option set to true.

{\bfseries  Note\+: } The draw() function of \hyperlink{class_animated_image}{Animated\+Image} class doesn\textquotesingle{}t need the buffer\+\_\+swap operation.

You can also print a specific frame of an animated image file\+: 
\begin{DoxyCode}
aIm.drawFrame(0);
led.swap\_buffer();
\end{DoxyCode}
 The value of frame number must be smaller than total frames, otherwise nothing will be printed on the screen. You can get total number of frames of an animated image by\+: 
\begin{DoxyCode}
\textcolor{keywordtype}{int} frames;
frames = aIm.getTotalFrames();
\end{DoxyCode}
 The result is an intger value.

{\bfseries  Show Text\+: }

Texts can be shown on the screen by using \hyperlink{class_string}{String} class. This class needs a font. You can convert any .ttf font to font supported by the library. In order to convert a font you can use a python script make\+\_\+font.\+py. This script depends on a pillow python library. You have to first install it\+: 
\begin{DoxyCode}
1 python -m pip install Pillow
\end{DoxyCode}
 The make\+\_\+font.\+py script accepts 3 arguments\+: font path, size of the font you want to use and the name of new font\+: 
\begin{DoxyCode}
1 python make\_font.py tahoma.ttf 10 tahoma10
\end{DoxyCode}
 The result is a .h file. A tahoma.\+ttf font converted with size of 10 to a supported font with name tahoma10. You can use this font by string class to show text or scroll text on the screen\+: 
\begin{DoxyCode}
\textcolor{preprocessor}{#include "tahoma10.h"}

\hyperlink{class_string}{String} str(led, tahoma10, (\textcolor{keywordtype}{char}*)\textcolor{stringliteral}{"Hallo World!"}, 0xFA0000, \hyperlink{classvector}{vector}(0, 10));
str.draw();
led.swap\_buffer(\textcolor{keyword}{false});
\end{DoxyCode}
 \char`\"{}\+Hallo World!\char`\"{} is the string to be written on the screen. You have to typecast your string first to char$\ast$. for example if you want to print \char`\"{}\+Hallo World\char`\"{} you have to pass it like this\+: (char$\ast$)\char`\"{}\+Hallo World\char`\"{}. You can also use R\+GB colors\+: 
\begin{DoxyCode}
\hyperlink{class_string}{String} str(led, tahoma10, (\textcolor{keywordtype}{char}*)\textcolor{stringliteral}{"Hallo World!"}, 255, 255, 255, \hyperlink{classvector}{vector}(0, 10));
\end{DoxyCode}


In order to scroll text from right to left on the screen you can use scroll function\+: 
\begin{DoxyCode}
str.scroll();
\end{DoxyCode}
 This function scrolls the text from right to left at the speed of 10 milliseconds. By default the loop is set to false and the start point of scroll is at width = 64; In order to change the default behavior you can declare the above function like this\+: 
\begin{DoxyCode}
str.scroll(15, \textcolor{keyword}{true}, 32);
\end{DoxyCode}
 The above code scrolls the text at the speed of 15 milliseconds per pixel and the loop is set to true. Also notice that the start point of scrolling is width = 32. It means the text will be scrolled from pixel(32, y) to pixel(0,y).

{\bfseries Note\+:} By using scroll function you do not need to use swap\+\_\+buffer(); 